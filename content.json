{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"mybatis知识总结","slug":"mybatis知识总结","date":"2019-09-23T11:02:41.000Z","updated":"2019-09-23T12:42:37.394Z","comments":true,"path":"2019/09/23/mybatis知识总结/","link":"","permalink":"http://yoursite.com/2019/09/23/mybatis知识总结/","excerpt":"","text":"在mybatis的配置文件中，取数值时用${} 自身不加’’,采用#{}自动加””。 一对一：业务扩展：添加一个新类并且继承其中一个类。 ​ resultmap：通过属性成员建立关系property代表类中的成员，column代表数据库中的字段（不区分大小写），如 &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt;&lt;result property=&quot;gradName&quot; column=&quot;gradname&quot;&gt;&lt;/result&gt;&lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt;&lt;result property=&quot;gradName&quot; column=&quot;gradname&quot;&gt;&lt;/result&gt;//一对一时，对象使用association映射；JavaType指定该属性的类型&lt;association prorperty=&quot;card&quot; javaType=&quot;StudentCard&quot;&gt;&lt;result property=&quot;cardinfo&quot; column=&quot;cardinfo&quot;&gt;&lt;/result&gt;&lt;/association&gt; 一对多：resultmap：collection返回的是一个对象集合，要把javaType转换成ofType,并且ofType对应的是集合中的元素类型。 &lt;!-- 配置成员属性 ，一对多 ；属性类型：javaType,属性的元素类型：ofType–&gt;` `&lt;collection property=&quot;students&quot; ofType=&quot;Student&quot;&gt;` `&lt;id/&gt;` `&lt;result property=&quot;gradName&quot; column=&quot;gradname&quot;&gt;&lt;/result&gt;` `&lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt;` `&lt;result property=&quot;gradName&quot; column=&quot;gradname&quot;&gt;&lt;/result&gt;` &lt;/collection&gt;` 数据库的字段与类中的属性数据类型不对应时可以采取的方法 创建一个java类，继承BaseTypeHandler&lt;数据类型&gt;，重写方法 首先在conf.xml配置 ``` `&lt;typeHandler handler=&quot;org.gyl.converter.BooleanAndIntConvert&quot; javaType=&quot;Boolean&quot; jdbcType=&quot;INTEGER&quot;/&gt;` ` 在Mapper.xml中： &lt;result property=&quot;sex&quot; column=&quot;sex&quot; javaType=&quot;boolean&quot; jdbcType=&quot;INTEGER&quot;&gt;&lt;/result&gt; mybatis调用存储过程 1234567891011 &lt;select id=\"queryByProcedure\" statementType=\"CALLABLE\" parameterType=\"HashMap\"&gt; &#123; CALL 存储过程名(#&#123;gname,jdbcType=\"VARCHAR\",mode=IN&#125;,#&#123;scount,jdbcType,mode=OUT&#125;) &#125;&lt;/select&gt;调用存储过程 Map map = new HashMap(); map.put(\"gname\", 1243); session.getMapper(StudentMapper.class).queryByProcedure(map); System.out.println(map.get(\"scount\")); foreach：将多个元素放在list中,stuNos是一个列表 &lt;iftest=”stuNos!=null and stuNos.size&gt;0”&gt;` `&lt;foreach collection=&quot;stuNos&quot; open=&quot; and stuNo in(&quot; close=&quot;)&quot; item=&quot;stuNo&quot; separator=&quot;,&quot;&gt;` `#{stuNo}` `&lt;/foreach&gt;` &lt;/if&gt;`将多个元素放在简单类型数组，在xml中必须用array.在paramterType中用数据类型[] 将多个元素放在对象数组时，在xml中必须用array ,在paramterType中用Object[] 关于parameterType和resultMap、resultType 当传入的参数为一个数组时，parameterType=”数据类型[]”。 resultMap可以在返回一个对象时，进行元素的修改。 resultType必须要匹配现有的数据类型和类中对应的元素。 延迟加载(如在加载学生信息时，并不立即加载学生证信息) 123456&lt;settings&gt; &lt;!-- 开启延迟加载 --&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!-- 关闭立即加载 --&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"/&gt;&lt;/settings&gt; 配置mapper.xml:写2个Mapper: 班级mapper.xml select c.* from studentclass c &lt;/select&gt; &lt;resultMap type=&quot;studentClass&quot; id=&quot;class_student_lazyLoad_map&quot;&gt; &lt;!-- 因为 type的主类是班级，因此先配置班级的信息--&gt; &lt;id property=&quot;classId&quot; column=&quot;classId&quot;/&gt; &lt;result property=&quot;className&quot; column=&quot;className&quot;/&gt; &lt;!-- 配置成员属性学生，一对多;属性类型：javaType，属性的元素类型ofType --&gt; &lt;!-- 2222222再查班级对应的学生 --&gt; &lt;collection property=&quot;students&quot; ofType=&quot;student&quot; select=&quot;org.lanqiao.mapper.StudentMapper.queryStudentsByClassId&quot; column=&quot;classid&quot;&gt; &lt;/collection&gt; &lt;/resultMap&gt; sql片段 12345678910111213141516​ &lt;sql id=\"objectarray\"&gt; &lt;where&gt; &lt;if test=\"array!=null and array.size&gt;0\"&gt; &lt;foreach collection=\"array\" open=\" and stuNo in(\" close=\")\" item=\"stuNo\" separator=\",\"&gt; #&#123;stuNo&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; &lt;/sql&gt; &lt;select id=\"querywithList\" parameterType=\"int[]\" resultMap=\"HashMap\" &gt; select * from student &lt;include refid=\"objectarray\"&gt;&lt;/include&gt; &lt;!-- 如果sql片段和引用出不在同一个文件 --&gt; &lt;include refid=\"org.gyl.xxx.objectarray\"&gt;&lt;/include&gt; &lt;/select&gt; 一级缓存和二级缓存","categories":[],"tags":[],"keywords":[]},{"title":"小常识","slug":"小常识","date":"2019-09-19T12:48:46.000Z","updated":"2019-09-23T12:44:29.039Z","comments":true,"path":"2019/09/19/小常识/","link":"","permalink":"http://yoursite.com/2019/09/19/小常识/","excerpt":"","text":"字符流和字节流的联系以及区别 字符流：reader 和 writer 处理单元为2个字节的Unicode字符，分别为操作字符、字符数组和字符串 字符流是由java虚拟机将字节转化为两个字节的Unicode字符为单位的字符而成的 适合关系到中文 只能处理字符或者字符串 字节流：inputstream 和outputstream 处理单元为1个字节 适合多国语言支持的文件、图片、歌曲 字节流可以处理任何类型的对象，包括二进制对象，但他不能直接处理unicode 字符 222","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}],"keywords":[]},{"title":"java设计模式包含的问题","slug":"java设计模式包含的问题","date":"2019-09-16T05:09:33.000Z","updated":"2019-09-21T07:06:04.935Z","comments":true,"path":"2019/09/16/java设计模式包含的问题/","link":"","permalink":"http://yoursite.com/2019/09/16/java设计模式包含的问题/","excerpt":"","text":"static怎样保证全局的唯一性？ ​ 静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问（方便） Tomcat下多个应用怎样让单例模式全局唯一？ ssss 单例模式怎样在分布式情况下保证实例唯一（用什么组件）？用什么方式保证单例的主机高可用？ ss 利用主从模式，ZooKeeper 实现了主从模式，如果想搭建一个能够允许 N 台机器 down 掉的集群，那么就要部署一个由 2*N+1 台服务器构成的 ZooKeeper 集群 深拷贝，浅拷贝. clone 是深拷贝还是浅拷贝？怎样实现的？深拷贝拷贝到不可变的那层？ 浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝。 深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝 对象实现Cloneable接口并重写Object类中的clone()方法（浅克隆方式） 对象实现Serializable接口，通过对象的序列化和反序列化实现克隆（此方法可以实现真正的深度克隆）。 详见https://blog.csdn.net/leixiaotao_java/article/details/69525224 拷贝到最后一层 什么叫spi,怎样实现。spi对应的类加载机制，java针对spi加载加载那个地方？ SPI机制（Service Provider Interface)其实源自服务提供者框架（Service Provider Framework)，是一种将服务接口与服务实现分离以达到解耦、大大提升了程序可扩展性的机制。 通过在ClassPath路径下的META-INF/services文件夹查找文件，自动加载文件里所定义的类 java.util.ServiceLoader 详见https://www.jianshu.com/p/3a3edbcd8f24 建造者模式与工厂模式的区别，建造者模式的变形 工厂模式用于处理 如何获取实例对象 问题，建造者模式用于处理 如何建造实例对象 问题 我们常用的并不是标准的建造者模式，而是建造者模式的一种变形，省略了设计者这个环节 详见https://blog.csdn.net/monkeyd5/article/details/73478940和https://blog.csdn.net/m0_37402140/article/details/78273047 Aop,spring 用什么方式实现Aop,实现代理的原理？ JDK动态代理：JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口，核心是InvocationHandler接口和Proxy类。 CGLIB动态代理：是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的 动态代理的使用及实现方式，原理 适配器的区别 ssss","categories":[],"tags":[{"name":"主页","slug":"主页","permalink":"http://yoursite.com/tags/主页/"}],"keywords":[]},{"title":"内网穿透","slug":"内网穿透","date":"2019-09-14T02:55:44.000Z","updated":"2019-09-14T07:20:48.986Z","comments":true,"path":"2019/09/14/内网穿透/","link":"","permalink":"http://yoursite.com/2019/09/14/内网穿透/","excerpt":"","text":"NatApp内网穿透 打开Ubuntu或者Centos，利用xshell或者其他工具远程连接。 在Ubuntu先检查是否安装了ssh: ps -e|grep ssh 安装ssh服务：sudo apt-get install openssh-server 启动ssh服务：sudo service ssh start 注册NatApp账号，购买隧道。Web隧道协议主要是访问内网网址，Tcp协议隧道主要是进行字节流的传输。 到https://natapp.cn/ 下载(配置linux)。 解压得到natapp，传输到linux上。 配置权限：sudo chmod a+x natapp。 启动natapp：sudo ./natapp authtoken=申请隧道的authtoken。 ​ web输入网址访问就OK, tcp 可以利用外网远程连接内网服务器。 ​","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}],"keywords":[]},{"title":"Hello World","slug":"hello-world","date":"2019-09-09T07:20:16.011Z","updated":"2019-08-15T13:31:47.188Z","comments":true,"path":"2019/09/09/hello-world/","link":"","permalink":"http://yoursite.com/2019/09/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}